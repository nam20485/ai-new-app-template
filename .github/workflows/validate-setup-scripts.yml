name: Validate setup scripts (Linux & Windows)

on:
  push:
    branches:
      - '**'
  pull_request:
    branches:
      - '**'
  workflow_dispatch:
    inputs:
      enableWindows:
        description: "Enable Windows validation job for this run"
        required: false
        default: 'false'

permissions:
  contents: read
  actions: read

jobs:
  decide-windows:
    name: Decide whether to run Windows validation
    runs-on: ubuntu-22.04
    outputs:
      enabled: ${{ steps.set.outputs.enabled }}
    steps:
      - id: set
        name: Determine enablement from dispatch input or repo variable
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO_SLUG: ${{ github.repository }}
          ENABLE_FROM_DISPATCH: ${{ inputs.enableWindows || '' }}
        run: |
          set -euo pipefail
          # If explicitly enabled via workflow_dispatch input, honor it
          if [ "${ENABLE_FROM_DISPATCH,,}" = "true" ]; then
            echo "enabled=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          owner="${REPO_SLUG%%/*}"
          repo="${REPO_SLUG#*/}"
          enabled="false"
          # Try to read repo actions variable ENABLE_WINDOWS_SETUP_VALIDATION; default to false if missing
          if gh api -H "Accept: application/vnd.github+json" \
                "/repos/${owner}/${repo}/actions/variables/ENABLE_WINDOWS_SETUP_VALIDATION" \
                > var.json 2>/dev/null; then
            # Parse value using jq if present, else fallback to grep
            if command -v jq >/dev/null 2>&1; then
              val=$(jq -r '.value // "false"' < var.json)
            else
              val=$(sed -n 's/.*"value"[[:space:]]*:[[:space:]]*"\(.*\)".*/\1/p' var.json | head -n1)
              [ -z "$val" ] && val="false"
            fi
            case "${val,,}" in
              true) enabled="true" ;;
              *) enabled="false" ;;
            esac
          fi
          echo "enabled=${enabled}" >> "$GITHUB_OUTPUT"

  validate-linux:
    name: Validate Linux setup script
    runs-on: ubuntu-22.04
    env:
      # Keep CI fast and less flaky: skip large optional installs (Playwright browsers, some CLIs)
      SETUP_MINIMAL: '1'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch Remote Scripts
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p scripts

          download() {
            filename="$1"
            # Pinned to a known-good commit for determinism
            sha="c20f87d445bd84ab33e9bc73005fc688fe9f9c8d"
            url="https://raw.githubusercontent.com/nam20485/agent-instructions/${sha}/scripts/${filename}"
            if curl -fsSL "$url" -o "scripts/${filename}"; then
              echo "Fetched $filename at $sha"
              return 0
            fi
            echo "Failed to fetch $filename at $sha" >&2
            exit 1
          }

          # overwrite local linux script with remote script
          download "setup-environment.sh"

      - name: Validate Linux script syntax
        shell: bash
        run: |
          set -euo pipefail
          if ! bash -n scripts/setup-environment.sh; then
            echo "Downloaded scripts/setup-environment.sh has a syntax error (bash -n failed)." >&2
            echo "Tip: upstream file may contain wrapped lines or unbalanced quotes; fix, then retry." >&2
            exit 1
          fi

      - name: Run Linux setup script
        shell: bash
        run: |
          chmod +x scripts/setup-environment.sh
          # Run with trace, capture logs, and preserve exit code from the script
          bash -x scripts/setup-environment.sh 2>&1 | tee setup-linux.log
          exit ${PIPESTATUS[0]}

      - name: Upload setup log (on failure)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: setup-linux-log
          path: setup-linux.log

  validate-windows:
    needs: decide-windows
    if: ${{ needs.decide-windows.outputs.enabled == 'true' }}
    name: Validate Windows setup script
    runs-on: windows-2022
    env:
      SETUP_MINIMAL: '1'
      NODE_VERSION_PIN: '22.11.0'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch Remote Scripts
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p scripts

          download() {
            filename="$1"
            # Pinned to a known-good commit for determinism
            sha="c20f87d445bd84ab33e9bc73005fc688fe9f9c8d"
            url="https://raw.githubusercontent.com/nam20485/agent-instructions/${sha}/scripts/${filename}"
            if curl -fsSL "$url" -o "scripts/${filename}"; then
              echo "Fetched $filename at $sha"
              return 0
            fi
            echo "Failed to fetch $filename at $sha" >&2
            exit 1
          }

          download "setup-environment.ps1"

      - name: Run Windows setup script
        shell: pwsh
        run: |
          # Preconfigure NVM environment so the current session can find nvm after install
          $env:NVM_HOME = "C:\ProgramData\nvm"
          $env:NVM_SYMLINK = "C:\Program Files\nodejs"
          if (!(Test-Path $env:NVM_SYMLINK)) { New-Item -ItemType Directory -Force -Path $env:NVM_SYMLINK | Out-Null }
          if (-not (($env:Path -split ';') -contains $env:NVM_HOME)) { $env:Path = "$env:NVM_HOME;$env:Path" }

          # Pre-install nvm in this step to avoid PATH/env propagation issues inside the setup script
          choco install -y nvm.install nvm | Write-Host
          $env:ChocolateyInstall = "C:\ProgramData\chocolatey"
          # Import Chocolatey profile so refreshenv is available, then refresh PATH/ENV
          $chocoProfile = Join-Path $env:ChocolateyInstall 'helpers\chocolateyProfile.psm1'
          if (Test-Path $chocoProfile) { Import-Module $chocoProfile -ErrorAction SilentlyContinue }
          if (Get-Command refreshenv -ErrorAction SilentlyContinue) {
            refreshenv
          } else {
            $env:Path = "C:\ProgramData\chocolatey\bin;$env:Path"
          }
          # Persist NVM variables at machine scope as some scripts validate on that scope
          [Environment]::SetEnvironmentVariable('NVM_HOME', $env:NVM_HOME, 'Machine')
          [Environment]::SetEnvironmentVariable('NVM_SYMLINK', $env:NVM_SYMLINK, 'Machine')

          # Ensure nvm is invokable even if PATH isn't refreshed
          $nvmExeCandidates = @(
            # Common install target for nvm-windows
            "$env:NVM_HOME\nvm.exe",
            # Default install path used by GUI installer
            "C:\\Program Files\\nvm\\nvm.exe",
            # Chocolatey shim location
            (Join-Path $env:ChocolateyInstall 'bin\nvm.exe'),
            # Chocolatey package tools locations (portable/content)
            (Join-Path $env:ChocolateyInstall 'lib\nvm\tools\nvm.exe'),
            (Join-Path $env:ChocolateyInstall 'lib\nvm.portable\tools\nvm.exe')
          )
          $nvmExe = $null
          foreach ($cand in $nvmExeCandidates) { if (Test-Path $cand) { $nvmExe = $cand; break } }
          # If still not found, attempt to run the GUI installer silently to lay down files in NVM_HOME
          if (-not $nvmExe) {
            $nvmSetup = Join-Path $env:ChocolateyInstall 'lib\nvm.install\tools\nvm-setup.exe'
            if (Test-Path $nvmSetup) {
              # Try common silent switches depending on installer tech; ignore failures but re-scan candidates after
              & $nvmSetup /VERYSILENT /NORESTART /DIR="$env:NVM_HOME" *>$null 2>$null
              & $nvmSetup /SILENT /NORESTART /DIR="$env:NVM_HOME" *>$null 2>$null
            }
            foreach ($cand in $nvmExeCandidates) { if (Test-Path $cand) { $nvmExe = $cand; break } }
          }
          if (-not $nvmExe) {
            Write-Host "Searched for nvm.exe in:"
            $nvmExeCandidates | ForEach-Object { Write-Host " - $_" }
            Write-Error "nvm.exe not found at expected locations"
            exit 1
          }
          & $nvmExe version | Write-Host
          # Add directory containing nvm.exe to PATH for the remainder of this step
          $env:Path = (Split-Path -Parent $nvmExe) + ';' + $env:Path

          & "scripts/setup-environment.ps1" *>&1 | Tee-Object -FilePath setup-windows.log
          $code = $LASTEXITCODE
          if ($code -ne 0) { exit $code }

      - name: Upload setup log (on failure)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: setup-windows-log
          path: |
            setup-windows.log
            C:\\ProgramData\\chocolatey\\logs\\chocolatey.log
